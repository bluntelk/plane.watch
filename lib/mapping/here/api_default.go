/*
 * Geocoding and Search API v7
 *
 * This document describes the Geocoding and Search API.
 *
 * API version: 7.78
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package here

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAutocompleteGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	q *string
	at *string
	in *string
	limit *int32
	types *[]string
	lang *[]string
	politicalView *string
	show *[]string
	xRequestID *string
}

func (r ApiAutocompleteGetRequest) Q(q string) ApiAutocompleteGetRequest {
	r.q = &q
	return r
}
func (r ApiAutocompleteGetRequest) At(at string) ApiAutocompleteGetRequest {
	r.at = &at
	return r
}
func (r ApiAutocompleteGetRequest) In(in string) ApiAutocompleteGetRequest {
	r.in = &in
	return r
}
func (r ApiAutocompleteGetRequest) Limit(limit int32) ApiAutocompleteGetRequest {
	r.limit = &limit
	return r
}
func (r ApiAutocompleteGetRequest) Types(types []string) ApiAutocompleteGetRequest {
	r.types = &types
	return r
}
func (r ApiAutocompleteGetRequest) Lang(lang []string) ApiAutocompleteGetRequest {
	r.lang = &lang
	return r
}
func (r ApiAutocompleteGetRequest) PoliticalView(politicalView string) ApiAutocompleteGetRequest {
	r.politicalView = &politicalView
	return r
}
func (r ApiAutocompleteGetRequest) Show(show []string) ApiAutocompleteGetRequest {
	r.show = &show
	return r
}
func (r ApiAutocompleteGetRequest) XRequestID(xRequestID string) ApiAutocompleteGetRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r ApiAutocompleteGetRequest) Execute() (OpenSearchAutocompleteResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.AutocompleteGetExecute(r)
}

/*
 * AutocompleteGet Autocomplete
 * BETA: This endpoint completes the few entered keystrokes to the valid street address or administrative area to speed-up entering the address queries.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAutocompleteGetRequest
 */
func (a *DefaultApiService) AutocompleteGet(ctx _context.Context) ApiAutocompleteGetRequest {
	return ApiAutocompleteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OpenSearchAutocompleteResponse
 */
func (a *DefaultApiService) AutocompleteGetExecute(r ApiAutocompleteGetRequest) (OpenSearchAutocompleteResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  OpenSearchAutocompleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AutocompleteGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/autocomplete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.q == nil {
		executionError.error = "q is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.in != nil {
		localVarQueryParams.Add("in", parameterToString(*r.in, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, "csv"))
	}
	if r.politicalView != nil {
		localVarQueryParams.Add("politicalView", parameterToString(*r.politicalView, ""))
	}
	if r.show != nil {
		localVarQueryParams.Add("show", parameterToString(*r.show, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		localVarHeaderParams["X-Request-ID"] = parameterToString(*r.xRequestID, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apiKey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiAutosuggestGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	q *string
	at *string
	in *string
	limit *int32
	route *string
	termsLimit *int32
	lang *[]string
	politicalView *string
	show *[]string
	xRequestID *string
}

func (r ApiAutosuggestGetRequest) Q(q string) ApiAutosuggestGetRequest {
	r.q = &q
	return r
}
func (r ApiAutosuggestGetRequest) At(at string) ApiAutosuggestGetRequest {
	r.at = &at
	return r
}
func (r ApiAutosuggestGetRequest) In(in string) ApiAutosuggestGetRequest {
	r.in = &in
	return r
}
func (r ApiAutosuggestGetRequest) Limit(limit int32) ApiAutosuggestGetRequest {
	r.limit = &limit
	return r
}
func (r ApiAutosuggestGetRequest) Route(route string) ApiAutosuggestGetRequest {
	r.route = &route
	return r
}
func (r ApiAutosuggestGetRequest) TermsLimit(termsLimit int32) ApiAutosuggestGetRequest {
	r.termsLimit = &termsLimit
	return r
}
func (r ApiAutosuggestGetRequest) Lang(lang []string) ApiAutosuggestGetRequest {
	r.lang = &lang
	return r
}
func (r ApiAutosuggestGetRequest) PoliticalView(politicalView string) ApiAutosuggestGetRequest {
	r.politicalView = &politicalView
	return r
}
func (r ApiAutosuggestGetRequest) Show(show []string) ApiAutosuggestGetRequest {
	r.show = &show
	return r
}
func (r ApiAutosuggestGetRequest) XRequestID(xRequestID string) ApiAutosuggestGetRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r ApiAutosuggestGetRequest) Execute() (OpenSearchAutosuggestResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.AutosuggestGetExecute(r)
}

/*
 * AutosuggestGet Autosuggest
 * This endpoint suggests address or place candidates based on an incomplete or misspelled query,
 from which the user selects the best query to submit.

_NOTE: The response may contain **experimental** elements not documented here.
 Any undocumented element is **subject to removal** at any time._

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAutosuggestGetRequest
 */
func (a *DefaultApiService) AutosuggestGet(ctx _context.Context) ApiAutosuggestGetRequest {
	return ApiAutosuggestGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OpenSearchAutosuggestResponse
 */
func (a *DefaultApiService) AutosuggestGetExecute(r ApiAutosuggestGetRequest) (OpenSearchAutosuggestResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  OpenSearchAutosuggestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AutosuggestGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/autosuggest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.q == nil {
		executionError.error = "q is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.in != nil {
		localVarQueryParams.Add("in", parameterToString(*r.in, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.route != nil {
		localVarQueryParams.Add("route", parameterToString(*r.route, ""))
	}
	if r.termsLimit != nil {
		localVarQueryParams.Add("termsLimit", parameterToString(*r.termsLimit, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, "csv"))
	}
	if r.politicalView != nil {
		localVarQueryParams.Add("politicalView", parameterToString(*r.politicalView, ""))
	}
	if r.show != nil {
		localVarQueryParams.Add("show", parameterToString(*r.show, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		localVarHeaderParams["X-Request-ID"] = parameterToString(*r.xRequestID, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apiKey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiBrowseGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	at *string
	categories *[]string
	chains *[]string
	foodTypes *[]string
	in *string
	limit *int32
	name *string
	route *string
	lang *[]string
	politicalView *string
	show *[]string
	xRequestID *string
}

func (r ApiBrowseGetRequest) At(at string) ApiBrowseGetRequest {
	r.at = &at
	return r
}
func (r ApiBrowseGetRequest) Categories(categories []string) ApiBrowseGetRequest {
	r.categories = &categories
	return r
}
func (r ApiBrowseGetRequest) Chains(chains []string) ApiBrowseGetRequest {
	r.chains = &chains
	return r
}
func (r ApiBrowseGetRequest) FoodTypes(foodTypes []string) ApiBrowseGetRequest {
	r.foodTypes = &foodTypes
	return r
}
func (r ApiBrowseGetRequest) In(in string) ApiBrowseGetRequest {
	r.in = &in
	return r
}
func (r ApiBrowseGetRequest) Limit(limit int32) ApiBrowseGetRequest {
	r.limit = &limit
	return r
}
func (r ApiBrowseGetRequest) Name(name string) ApiBrowseGetRequest {
	r.name = &name
	return r
}
func (r ApiBrowseGetRequest) Route(route string) ApiBrowseGetRequest {
	r.route = &route
	return r
}
func (r ApiBrowseGetRequest) Lang(lang []string) ApiBrowseGetRequest {
	r.lang = &lang
	return r
}
func (r ApiBrowseGetRequest) PoliticalView(politicalView string) ApiBrowseGetRequest {
	r.politicalView = &politicalView
	return r
}
func (r ApiBrowseGetRequest) Show(show []string) ApiBrowseGetRequest {
	r.show = &show
	return r
}
func (r ApiBrowseGetRequest) XRequestID(xRequestID string) ApiBrowseGetRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r ApiBrowseGetRequest) Execute() (OpenSearchBrowseResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.BrowseGetExecute(r)
}

/*
 * BrowseGet Browse
 * This endpoint provides search results for places based on different filters, such as categories or name, ranked by distance from a given search center.
The only mandatory elements exposed in the response are id and position. The other elements shown in the response samples section are only dataset attributes suggestions.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiBrowseGetRequest
 */
func (a *DefaultApiService) BrowseGet(ctx _context.Context) ApiBrowseGetRequest {
	return ApiBrowseGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OpenSearchBrowseResponse
 */
func (a *DefaultApiService) BrowseGetExecute(r ApiBrowseGetRequest) (OpenSearchBrowseResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  OpenSearchBrowseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.BrowseGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/browse"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.at == nil {
		executionError.error = "at is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	if r.categories != nil {
		localVarQueryParams.Add("categories", parameterToString(*r.categories, "csv"))
	}
	if r.chains != nil {
		localVarQueryParams.Add("chains", parameterToString(*r.chains, "csv"))
	}
	if r.foodTypes != nil {
		localVarQueryParams.Add("foodTypes", parameterToString(*r.foodTypes, "csv"))
	}
	if r.in != nil {
		localVarQueryParams.Add("in", parameterToString(*r.in, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.route != nil {
		localVarQueryParams.Add("route", parameterToString(*r.route, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, "csv"))
	}
	if r.politicalView != nil {
		localVarQueryParams.Add("politicalView", parameterToString(*r.politicalView, ""))
	}
	if r.show != nil {
		localVarQueryParams.Add("show", parameterToString(*r.show, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		localVarHeaderParams["X-Request-ID"] = parameterToString(*r.xRequestID, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apiKey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiDiscoverGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	q *string
	at *string
	in *string
	limit *int32
	route *string
	lang *[]string
	politicalView *string
	show *[]string
	xRequestID *string
}

func (r ApiDiscoverGetRequest) Q(q string) ApiDiscoverGetRequest {
	r.q = &q
	return r
}
func (r ApiDiscoverGetRequest) At(at string) ApiDiscoverGetRequest {
	r.at = &at
	return r
}
func (r ApiDiscoverGetRequest) In(in string) ApiDiscoverGetRequest {
	r.in = &in
	return r
}
func (r ApiDiscoverGetRequest) Limit(limit int32) ApiDiscoverGetRequest {
	r.limit = &limit
	return r
}
func (r ApiDiscoverGetRequest) Route(route string) ApiDiscoverGetRequest {
	r.route = &route
	return r
}
func (r ApiDiscoverGetRequest) Lang(lang []string) ApiDiscoverGetRequest {
	r.lang = &lang
	return r
}
func (r ApiDiscoverGetRequest) PoliticalView(politicalView string) ApiDiscoverGetRequest {
	r.politicalView = &politicalView
	return r
}
func (r ApiDiscoverGetRequest) Show(show []string) ApiDiscoverGetRequest {
	r.show = &show
	return r
}
func (r ApiDiscoverGetRequest) XRequestID(xRequestID string) ApiDiscoverGetRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r ApiDiscoverGetRequest) Execute() (OpenSearchSearchResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.DiscoverGetExecute(r)
}

/*
 * DiscoverGet Discover
 * This endpoint processes a free-form text query for an address or place, and returns results in order of relevance.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDiscoverGetRequest
 */
func (a *DefaultApiService) DiscoverGet(ctx _context.Context) ApiDiscoverGetRequest {
	return ApiDiscoverGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OpenSearchSearchResponse
 */
func (a *DefaultApiService) DiscoverGetExecute(r ApiDiscoverGetRequest) (OpenSearchSearchResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  OpenSearchSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DiscoverGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/discover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.q == nil {
		executionError.error = "q is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.in != nil {
		localVarQueryParams.Add("in", parameterToString(*r.in, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.route != nil {
		localVarQueryParams.Add("route", parameterToString(*r.route, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, "csv"))
	}
	if r.politicalView != nil {
		localVarQueryParams.Add("politicalView", parameterToString(*r.politicalView, ""))
	}
	if r.show != nil {
		localVarQueryParams.Add("show", parameterToString(*r.show, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		localVarHeaderParams["X-Request-ID"] = parameterToString(*r.xRequestID, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apiKey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGeocodeGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	at *string
	in *string
	limit *int32
	q *string
	qq *string
	lang *[]string
	politicalView *string
	show *[]string
	xRequestID *string
}

func (r ApiGeocodeGetRequest) At(at string) ApiGeocodeGetRequest {
	r.at = &at
	return r
}
func (r ApiGeocodeGetRequest) In(in string) ApiGeocodeGetRequest {
	r.in = &in
	return r
}
func (r ApiGeocodeGetRequest) Limit(limit int32) ApiGeocodeGetRequest {
	r.limit = &limit
	return r
}
func (r ApiGeocodeGetRequest) Q(q string) ApiGeocodeGetRequest {
	r.q = &q
	return r
}
func (r ApiGeocodeGetRequest) Qq(qq string) ApiGeocodeGetRequest {
	r.qq = &qq
	return r
}
func (r ApiGeocodeGetRequest) Lang(lang []string) ApiGeocodeGetRequest {
	r.lang = &lang
	return r
}
func (r ApiGeocodeGetRequest) PoliticalView(politicalView string) ApiGeocodeGetRequest {
	r.politicalView = &politicalView
	return r
}
func (r ApiGeocodeGetRequest) Show(show []string) ApiGeocodeGetRequest {
	r.show = &show
	return r
}
func (r ApiGeocodeGetRequest) XRequestID(xRequestID string) ApiGeocodeGetRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r ApiGeocodeGetRequest) Execute() (OpenSearchGeocodeResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GeocodeGetExecute(r)
}

/*
 * GeocodeGet Geocode
 * This endpoint allows to find the geo-coordinates of a known address, place, locality or administrative area, even if the query is incomplete or partly incorrect. It also returns a complete postal address string and address details. It supports structured, unstructured and hybrid queries - combinations of structured and unstructured query elements.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGeocodeGetRequest
 */
func (a *DefaultApiService) GeocodeGet(ctx _context.Context) ApiGeocodeGetRequest {
	return ApiGeocodeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OpenSearchGeocodeResponse
 */
func (a *DefaultApiService) GeocodeGetExecute(r ApiGeocodeGetRequest) (OpenSearchGeocodeResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  OpenSearchGeocodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GeocodeGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/geocode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.in != nil {
		localVarQueryParams.Add("in", parameterToString(*r.in, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.qq != nil {
		localVarQueryParams.Add("qq", parameterToString(*r.qq, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, "csv"))
	}
	if r.politicalView != nil {
		localVarQueryParams.Add("politicalView", parameterToString(*r.politicalView, ""))
	}
	if r.show != nil {
		localVarQueryParams.Add("show", parameterToString(*r.show, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		localVarHeaderParams["X-Request-ID"] = parameterToString(*r.xRequestID, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apiKey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiLookupGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	id *string
	lang *[]string
	politicalView *string
	show *[]string
	xRequestID *string
}

func (r ApiLookupGetRequest) Id(id string) ApiLookupGetRequest {
	r.id = &id
	return r
}
func (r ApiLookupGetRequest) Lang(lang []string) ApiLookupGetRequest {
	r.lang = &lang
	return r
}
func (r ApiLookupGetRequest) PoliticalView(politicalView string) ApiLookupGetRequest {
	r.politicalView = &politicalView
	return r
}
func (r ApiLookupGetRequest) Show(show []string) ApiLookupGetRequest {
	r.show = &show
	return r
}
func (r ApiLookupGetRequest) XRequestID(xRequestID string) ApiLookupGetRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r ApiLookupGetRequest) Execute() (LookupResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.LookupGetExecute(r)
}

/*
 * LookupGet Lookup By ID
 * This endpoint looks up a known place by the HERE ID included in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiLookupGetRequest
 */
func (a *DefaultApiService) LookupGet(ctx _context.Context) ApiLookupGetRequest {
	return ApiLookupGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return LookupResponse
 */
func (a *DefaultApiService) LookupGetExecute(r ApiLookupGetRequest) (LookupResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  LookupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LookupGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/lookup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id == nil {
		executionError.error = "id is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, "csv"))
	}
	if r.politicalView != nil {
		localVarQueryParams.Add("politicalView", parameterToString(*r.politicalView, ""))
	}
	if r.show != nil {
		localVarQueryParams.Add("show", parameterToString(*r.show, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		localVarHeaderParams["X-Request-ID"] = parameterToString(*r.xRequestID, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apiKey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiRevgeocodeGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	at *string
	in *string
	limit *int32
	lang *[]string
	politicalView *string
	show *[]string
	xRequestID *string
}

func (r ApiRevgeocodeGetRequest) At(at string) ApiRevgeocodeGetRequest {
	r.at = &at
	return r
}
func (r ApiRevgeocodeGetRequest) In(in string) ApiRevgeocodeGetRequest {
	r.in = &in
	return r
}
func (r ApiRevgeocodeGetRequest) Limit(limit int32) ApiRevgeocodeGetRequest {
	r.limit = &limit
	return r
}
func (r ApiRevgeocodeGetRequest) Lang(lang []string) ApiRevgeocodeGetRequest {
	r.lang = &lang
	return r
}
func (r ApiRevgeocodeGetRequest) PoliticalView(politicalView string) ApiRevgeocodeGetRequest {
	r.politicalView = &politicalView
	return r
}
func (r ApiRevgeocodeGetRequest) Show(show []string) ApiRevgeocodeGetRequest {
	r.show = &show
	return r
}
func (r ApiRevgeocodeGetRequest) XRequestID(xRequestID string) ApiRevgeocodeGetRequest {
	r.xRequestID = &xRequestID
	return r
}

func (r ApiRevgeocodeGetRequest) Execute() (OpenSearchReverseGeocodeResponse, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.RevgeocodeGetExecute(r)
}

/*
 * RevgeocodeGet Reverse Geocode
 * This endpoint returns the nearest address to geo coordinates specified in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRevgeocodeGetRequest
 */
func (a *DefaultApiService) RevgeocodeGet(ctx _context.Context) ApiRevgeocodeGetRequest {
	return ApiRevgeocodeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OpenSearchReverseGeocodeResponse
 */
func (a *DefaultApiService) RevgeocodeGetExecute(r ApiRevgeocodeGetRequest) (OpenSearchReverseGeocodeResponse, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  OpenSearchReverseGeocodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RevgeocodeGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/revgeocode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.at != nil {
		localVarQueryParams.Add("at", parameterToString(*r.at, ""))
	}
	if r.in != nil {
		localVarQueryParams.Add("in", parameterToString(*r.in, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, "csv"))
	}
	if r.politicalView != nil {
		localVarQueryParams.Add("politicalView", parameterToString(*r.politicalView, ""))
	}
	if r.show != nil {
		localVarQueryParams.Add("show", parameterToString(*r.show, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		localVarHeaderParams["X-Request-ID"] = parameterToString(*r.xRequestID, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apiKey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}
